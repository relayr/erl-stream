# stream

[![Build Status](https://travis-ci.org/relayr/erl-stream.svg?branch=master)](https://travis-ci.org/relayr/erl-stream) [![Coverage Status](https://coveralls.io/repos/github/relayr/erl-stream/badge.svg?branch=master)](https://coveralls.io/github/relayr/erl-stream?branch=master)

## Description

Stream library allows operations on potentially infinite data structures that use lazy evaluation. Streams are represented as functions that when called return next element from the stream and next stream function that can be called iteratively until `end_of_stream` atom is returned.

---
## Exported types
```
-type stream(T) :: fun(() -> {Head :: T | end_of_stream, Tail :: fun(() -> stream(T))}).
-type stream() :: stream(any()).
```

## Examples
### Create functions

#### stream:from_list/1
Create finite stream with values `1..10`.
```
1> S0 = stream:from_list(lists:seq(1,10)).
#Fun<stream.0.33323752>
2> stream:to_list(S0).
[1,2,3,4,5,6,7,8,9,10]
```

---
#### stream:from_file/1,2
Create stream from disk file with stream chunks of given size.
When stream is consumed content of the file is read in chunks of ChunkSize-bytes.
In case of any error a tuple {error, ErrorReason} is returned by stream.
```
1> S = stream:from_file("rebar.config", 20).
#Fun<stream.20.33323752>
2> stream:to_list(S).
[<<>>,<<"{deps, []}.\n\n{profil">>,
 <<"es, [\n    {test, [\n ">>,<<"       {deps, []}\n  ">>,
 <<"   ]}\n]}.\n">>]
```

---
#### stream:from_reader/1
Create infinite stream that returns values generated by input function i.e. random integers.
```
1> S1 = stream:from_reader(fun() -> rand:uniform(5) end).
#Fun<stream.4.33323752>
```

---
#### stream:from_stateful_reader/2
Create potentially infinite stream that returns values generated by input function that accepts an accumulator. When `end_of_stream` atom is returned reading the stream is finished.
```
1> S1 = stream:from_stateful_reader(fun(0) -> {end_of_stream, 0}; (N) -> {N, N-1} end, 7).
#Fun<stream.5.33323752>
2> stream:to_list(S1).
[7,6,5,4,3,2,1]
```

---
### Operate functions

#### stream:next/1
Consume stream to return next elements. If stream is fully consumed `stream:next/1` returns `end_of_stream` atom.
```
1> S0 = stream:from_list(lists:seq(1,10)).
#Fun<stream.0.33323752>
2> {Elem1, S1} = stream:next(S0).
{1,#Fun<stream.0.33323752>}
3> Elem1.
1
4> {Elem2, S2} = stream:next(S1).
{2,#Fun<stream.0.33323752>}
...
15> {Elem10, S10} = stream:next(S9).
{10,#Fun<stream.3.33323752>}
16> {Elem11, S11} = stream:next(S10).
{end_of_stream,#Fun<stream.3.33323752>}
17> Elem11
end_of_stream
```

---
### Map functions


#### stream:map/2
Map elements in the stream and create new result stream.
```
1> S1 = stream:from_list(lists:seq(1,10)).
#Fun<stream.0.33323752>
2> S2 = stream:map(S1, fun(E) -> E * 1.5 end).
#Fun<stream.8.33323752>
3> stream:to_list(S2).
[1.5,3.0,4.5,6.0,7.5,9.0,10.5,12.0,13.5,15.0]
```

---
#### stream:foreach/2
Create new stream that when consumed executes function `fun((E) -> _)` for each of elements in the stream. Elements returned from the stream are not changed by transform function.
```
1> S1 = stream:from_list(lists:seq(1,10)).
#Fun<stream.0.33323752>
2> S2 = stream:foreach(S1, fun(E) -> io:format("Element: ~p~n", [E * 1.0]) end).
#Fun<stream.7.33323752>
3> stream:to_list(S2).
Element: 1.0
Element: 2.0
Element: 3.0
Element: 4.0
Element: 5.0
Element: 6.0
Element: 7.0
Element: 8.0
Element: 9.0
Element: 10.0
[1,2,3,4,5,6,7,8,9,10]
```

---
#### stream:filter/2
Filter stream to create new stream that contain only elements matching given filter function.
```
1> S1 = stream:from_list(lists:seq(1,10)).
#Fun<stream.0.33323752>
2> S2 = stream:filter(S1, fun(E) -> E rem 3 == 0 end).
#Fun<stream.10.33323752>
3> stream:to_list(S2).
[3,6,9]
```

---
#### stream:dropwhile/2, stream:takewhile/2
Create new stream that drops elements from the input stream until condition is met.
```
1> S1 = stream:from_list(lists:seq(1,10)).
#Fun<stream.0.33323752>
2> S2 = stream:dropwhile(S1, fun(E) -> E < 5 end).
#Fun<stream.12.33323752>
3> stream:to_list(S2).
[5,6,7,8,9,10]
```

Create new stream that returns elements from the input stream until condition is met.
```
1> S1 = stream:from_list(lists:seq(1,10)).
#Fun<stream.0.33323752>
2> S2 = stream:takewhile(S1, fun(E) -> E < 5 end).
#Fun<stream.12.33323752>
3> stream:to_list(S2).
[1,2,3,4]
```

---
### Reduce functions

#### stream:reduce/3
Reduce elements in the stream using accumulator function.
```
1> S1 = stream:from_list(lists:seq(1,10)).
#Fun<stream.0.33323752>
2> stream:reduce(S1, 0, fun(E, Acc) -> E + Acc end).
55
```

---
#### stream:find/2
Find first element in the stream that matches given filter function. If no matches are found `undefined` is returned.
```
1> S1 = stream:from_list(lists:seq(1,10)).
#Fun<stream.0.33323752>
2> stream:find(S1, fun(E) -> E rem 3 == 0 end).
{ok,3}
3> stream:find(S1, fun(E) -> E rem 3 == 4 end).
undefined
```

---
#### stream:any/2, stream:all/2
Check if any or all of elements in the stream match some criteria.
```
1> S1 = stream:from_list([1,5,3,5,8,9,2,7]).
#Fun<stream.0.33323752>
2> stream:any(S1, fun(E) -> E rem 4 == 0 end).  % 8 rem 4 == 0
true
3> stream:all(S1, fun(E) -> E < 9 end).         % 9 < 9 = false
false
```

## Licensing

This code is licensed under MIT license.

Special thanks goes to [@sjanota](https://github.com/sjanota) for initial version of this library.